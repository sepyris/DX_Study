#include "framework.h"
#include "Control.h"

Control::Control()
	: cur_state{}, old_state{}, map_state{}
	// 배열은 타겟 생성자를 쓸 때 ()가 아닌 {}를 이용하여 초기화함
	// 그 외엔 별다른 차이점은 없다
{
}

Control::~Control()
{
}

void Control::Update()
{
	memcpy(old_state, cur_state, sizeof(old_state));
	// 왼쪽 포인터에 오른쪽 포인터가 가지고 있는 값들을 복사하는 함수
	// 복사하는 범위는 old_state가 가지고 있는 용량만큼
	// -> 업데이트를 하는 시점에 cur_state의 값을 old_state로 넘기기

	GetKeyboardState(cur_state);
	// BYTE[255] 배열에 현 시점의 키보드 중 어느 키가 눌렸는지에 대한 정보를
	// 전부 기록하는 함수
	// 이를 통해 키보드의 각 키(+마우스의 키)가 현재 눌려있는지의 여부를 저장

	// 이 뒤에 있을 내용을 설명하기 위해서라도
	// 시스템에서 각 키가 눌렸을 때 정보가 어떻게 저장되는지를 체크해봐야 함

	// 키가 눌려있을 경우, 해당 키에 대응하는 값은 128이나 129 중 하나를 가짐
	// 눌려있지 않을 경우엔 0이나 1 중 하나를 가지고 있음
	// 시스템상에서는 각 키가 눌릴 떄마다 
	// 128 -> 0 -> 129 -> 1 -> 128 -> ...의 순서대로 값이 변함
	// 이렇게 순환시키면서 눌렸는지 혹은 눌리지 않았는지를 체크하는 것

	for (int i = 0; i < KEY_MAX; i++)
	// -> 키보드의 각각의 키들을 관리하는 반복문
	// 매 루프마다 키보드의 키 중 하나의 현재 상태를 업데이트
	{
		BYTE key = cur_state[i] & 0x80;
		// 0x80 == 128, 위에서 설명했던
		// 시스템에서 해당 키가 눌려있을 경우 할당되는 비트
		// -> 입력된 값과 128을 AND 비트 연산하여 
		// 128에 해당되는 값을 제외한 나머지 비트의 값을 싹 날림

		cur_state[i] = key ? 1 : 0;
		// 키가 눌려있다면 cur_state는 128, 129 중 하나의 값을 가짐
		// 0x80 || 0x81
		// 둘 중 어느 값이더라도 같은 코드에서 똑같이 대응하도록 하기 위해
		// 위에서의 key로 가공을 한 뒤,
		// 그 비트의 값을 128에서 1로 바꿈으로서
		// 눌렸다면 1, 아니라면 0이라는 값을 가지도록 최종 가공

		BYTE old = old_state[i];
		BYTE cur = cur_state[i];
		// 현재 검사하는 키가 직전에 눌렸는지 + 지금 눌려있는지를 체크하는 변수
		// 2개를 만들어둠

		if (old == 0 && cur == 1) // 직전 타이밍에 안 눌렸다가 지금 막 눌렸다
		{
			map_state[i] = DOWN;
			// == 막 눌렸다는 이야기니 DOWN
		}
		else if (old == 1 && cur == 1) // 직전에도 눌렸고 지금도 눌렸다
		{
			map_state[i] = PRESS;
			// == 계속해서 눌리고 있으니 PRESS
		}
		else if (old == 1 && cur == 0) // 직전엔 눌렸는데 지금 떼졌다
		{
			map_state[i] = UP;
			// == 막 떼졌단 이야기니
		}
		else // 직전도 지금도 눌리지 않은 상황
		{
			map_state[i] = NONE;
		}
	}
}
