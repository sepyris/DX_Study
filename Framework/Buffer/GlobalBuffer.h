#pragma once
// 이 헤더는 앞으로 필요한 상수 버퍼가 있을 때마다
// 그 버퍼들을 정의하는 구간

// 상수 버퍼라는 것이 사용처가 굉장히 많아서
// 앞으로 DX 프로그램을 만들어나갈 때마다 추가하게 되는 버퍼가 좀 있는 관계로
// 필요할 떄마다 여기에 정의

class MatrixBuffer : public ConstBuffer
	// MatrixBuffer : 3차원 공간과 관련된 연산을 하는 데 필요한
	// 행렬을 저장하는 용도의 버퍼
{
private:
	struct Data
	{
		Matrix matrix;
	} data;

public:
	MatrixBuffer() : ConstBuffer(&data, sizeof(data))
	{
		data.matrix = XMMatrixIdentity();
		// 단위행렬을 만드는 함수를 통해
		// 초기값을 단위행렬로 초기화

		// 앞으로 우리가 진행할 내용을 이해하기 위해선
		// 삼각함수, *행렬의 곱셈, 단위행렬*,
		// 수학에서의 벡터, 정확히는 그 벡터의 외적 및 내적
		// 등등의 개념을 알아둬야 진행할 수 있음

		// 기초반에서 이를 전부 설명하기는 매우 어려우니,
		// 미리 해당 개념들을 익혀올 것을 권장

		// 질문 - 4X4 크기의 단위행렬은 어떻게 생겼는가?
		/*
		1 0 0 0
		0 1 0 0
		0 0 1 0
		0 0 0 1
		*/
		// 2번째 질문 - 왜 단위행렬이 이렇게 생겼는가?
		// -> 이 행렬과 곱셈이 가능한 어떤 행렬에 곱하더라도
		// 행렬의 곱셈이 진행되는 방식을 생각했을 때
		// 항상 곱하기 전의 행렬이 그대로 유지되는 행렬이기 때문

		// 수학에는 "항등원"과 "역원"이라는 개념이 있음
		// 똑같은 한 종류의 연산에 대해서(덧셈, 곱셈 등)
		// 항등원 : 어떤 수에 이 수를 이용해 연산했을 경우 
		// 항상 그 어떤 수가 그대로 유지되는 값
		// 덧셈의 경우엔 0,  곱셈의 경우엔 1
		// 역원 : 어떤 수가 있을 때,
		// 이 수에 연산을 했을 때 결과물로 항등원이 나오는 수
		// 덧셈의 경우엔 1의 역원은 -1
		// 곱셈의 경우엔 12의 역원은 1/12

		// 이런 식으로 "무언가 한 종류의 연산이 성립하는 수 체계 안에서는
		// 어지간하면 항등원과 역원이 존재한다고 볼 수 있다"라 할 수 있고
		// 그걸 행렬에서 따지는 것이 위의 단위행렬

		// XMMatrixIdentity : 그런 단위행렬,
		// 정확히는 그 단위행렬 중 3D 그래픽스에서 주로 사용하는 행렬 사이즈인
		// 4X4 행렬의 단위행렬을 만들어주는 함수
		// 따라서 본 MatrixBuffer는 생성 시 4X4 크기의 단위행렬을 가지게 됨

	}
	~MatrixBuffer() {};

	void Set(Matrix value)
	{
		data.matrix = XMMatrixTranspose(value);
		// 행렬의 데이터를 다른 행렬로 복사하는
		// 행렬 적용 복사함수
	}
};

class ColourBuffer : public ConstBuffer
	// ColourBuffer : 색상을 픽셀 셰이더에 등록할 때 사용할 버퍼를 클래스화한 것
	// 앞으로는 정점만을 통해 색을 관리하지 않고
	// 도형 그 자체가 가지고 있는 색상 버퍼를 통해서 
	// 도형 전체의 색상값을 관리하도록 만들 예정
{
public:
	struct Data
	{
		Float4 colour;
	} data;

	ColourBuffer() : ConstBuffer(&data, sizeof(data))
	{
		data.colour = Float4(1.0f, 1.0f, 1.0f, 1.0f);
		// 초기값은 흰색을 지정하는 실수 4개의 집합
	}
};


