#pragma once
// 우리가 DX를 사용한다고는 하지만,
// 그 구조는 우리가 직접 DX에서 제공하는 함수 등을 이용해 
// 직접 모든 처리를 하는 게 아니고
// DX가 처리할 수 있는 식으로 우리가 데이터를 가공하고 나면
// 이를 DX 쪽의 장치에 던져서 그래픽 작업을 시행하도록 위틱하는 구조

// -> DX를 사용하려면 DX에서 정의되어 있는 클래스들의 객체를 만들어
// 우리가 그래픽을 출력할 데이터를 관리할 장치 그 자체를 활성화시켜야 함

// 그런 작업들을 전부 도맡아 담당하는 것이 Device 클래스
// 이 클래스는 한 프로그램에서 둘 이상 존재하면 안되므로
// (그래픽을 출력하는 주체가 하나가 아니라 둘이면 화면 처리가 이상해질 수 밖에 없음)
// 둘 이상의 객체가 만들어지는 것을 막기 위해 Singleton으로 만듦

class Device : public Singleton<Device>
{
private:
	friend class Singleton;
	// friend : 간단히 말하면 private 자유이용권
	// 한 클래스에서 friend로 선언한 클래스는 이 클래스의 내부에서 
	// 해당 클래스의 private, protected 등을 자유롭게 사용가능
	// -> Device 내부에서 Singleton 내부의 private, protected에 있는 멤버들을
	// 자기 클래스의 private인 마냥 사용할 수 있는 것

	// Singleton의 Get() 함수를 이용할 떄, 위 구문이 없으면
	// 이 Control 함수에서는 Singleton의 instance에 접근을 할 수 없어서
	// 아예 Get() 함수의 이용 자체가 불가능해지기 때문에
	// 반드시 여기서 붙여줘야 함

	ID3D11Device* device;    // CPU의 연산, 리소스 로딩 등 출력 외 다른 기능들을 종합적으로 하는 기본 장치
	ID3D11DeviceContext* device_context; // GPU에서 하는 일을 여기서 담당

	IDXGISwapChain* swap_chain;  // 더블버퍼링에 사용되는 객체
	ID3D11RenderTargetView* render_target_view;   // 후면버퍼에서 사용할 메모리

	// 이상 4개가 DX의 기능을 사용하기 위해 만들게 되는,
	// 다시말해 DirectX의 장치 그 자체를 담당할 클래스들

	// 이하의 내용은 "싱글톤"이라는 디자인 패턴을 적용한 것
	// 디자인 패턴 : 기존에 프로그램을 만들 떄 사용된 기법들 중
	// 유명하고 검증된 것을 도입해 사용하는 것
	
	// 싱글톤(Singleton) : 한 프로그램에 둘 이상 만들어져서는 안 되는 클래스를
	// 쉽게 구현하기 위해 적용하는 디자인 패턴
	// 둘 이상의 인스턴스가 생기는 것 그 자체를 막고,
	// 이 클래스의 인스턴스가 필요하면 
	// static 전역 변수로 유일한 객체에 접근할 수 있게 하는 식으로 구성하는 방식

	/* 부모 클래스에서 처리하는 내용이니 더이상 여기선 필요없음
	static Device* instance;
	// 이 클래스의 유일한 인스턴스를 반환할 수 있도록
	// static 멤버 변수로 선언을 해두고
	*/

	Device();
	~Device();
	// 유일한 인스턴스를 만들어내는/삭제하는 방법 외에 다른 경로로
	// 이 클래스의 유일한 인스턴스가 만들어지거나 삭제되어
	// 이 클래스의 인스턴스가 둘 이상이 되거나
	// 이를 삭제하려고 의도하지 않았는데 삭제되는 경우를 막기 위해
	// 아예 생성자와 소멸자 자체를 private으로 만들어서
	// 이 클래스 외부에서 이 함수들을 불러오는 것 자체를 막음

public:

	/*
	// 그렇게 생성자와 소멸자를 밖에서 만드는 것을 막아버렸다면,
	// 다르게 말하면 이 클래스가 private으로 가지고 있는 
	// instance 외의 다른 인스턴스는 존재하지 않음,
	// 즉 클래스 외부에서 그 유일한 인스턴스에 접근할 방법이 존재하지 않음

	// 그래서 접근을 할 수 있게 아래의 Get이라는 static 함수를 통해
	// 인스턴스에 접근하는 접근자를 만드는 것
	static Device* Get()
	{
		// 클래스 외부에서는 객체를 만들 수 없음
		// 그러니 이 함수를 통해 유일한 인스턴스에 접근을 해야 하는데

		// 이 싱글톤 클래스가 처음 불린 경우라면
		// 당연하다시피 그 유일한 인스턴스라는 게 아직 만들어지지 않은 상황
		if (instance == nullptr)
			instance = new Device();
		// 그렇다면 처음 이 클래스의 유일한 인스턴스를 찾는 상황이 되었을 때
		// 그 자리에서 그 인스턴스를 만드는 것으로 접근이 가능해짐
		// 이 방식으로 이 클래스의 인스턴스를 만드는 것과
		// 그냥 호출만 하는 것을 하나의 함수에 묶는 것으로
		// 생성과 이용을 동시에 실행할 수 있게 함

		return instance;
	}

	static void Delete() { delete instance; }
	// 소멸자 역시 외부에서 건드릴 수 없으므로
	// 이렇게 직접 소멸자를 호출하는 걸 통해
	// 프로그램을 종료하는 상황 등에서 소멸자가 작동하게 만드는 함수
	// 나중에 직접 이 함수를 부르는 것으로 프로그램 마무리를 할 때 진행
	*/
	// 이상의 내용은 아직 Singleton 부모 클래스를 만들기 전에
	// 여기서 직접 싱글톤으로 구현한 것으로,
	// 저 부모 클래스를 구현한 이상 여기서 직접 구성해줄 필요는 더 이상 없음
	
	void CreateDeviceAndSwapChain();
	// 디바이스와 스왑체인(=더블 버퍼링)을 초기화(=생성)하는 함수
	// 여기를 통해 DX를 이용하는 데 제일 중요한 클래스들을 초기화
	void CreateBackBuffer();
	// 더블 버퍼링 등에 이용하게 되는 백버퍼를 만드는 함수
	void SetViewPoint();
	// 이것에 대한 설명은 후일 이 함수를 건드리게 되는 날이 왔을 때 설명

	void Clear(); // 화면을 (지정된 배경색으로) 초기화하는 함수
	void Present(); // 더블 버퍼링을 시행하는 함수

	ID3D11Device* GetDevice() { return device; }
	ID3D11DeviceContext* GetDeviceContext() { return device_context; }
};