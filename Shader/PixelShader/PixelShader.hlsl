cbuffer Color : register(b0)
{
	float4 color;
} // 이번에 출력할 픽셀에서 어떤 색상을 출력할 것인지 결정하는 데
  // 영향을 미치는 색상값이 기록된 버퍼를 전달받아 저장

// VS 측과 마찬가지로 메인 프로젝트 쪽에서
// 버퍼를 픽셀 셰이더에 입력할 경우 이 슬롯을 통해 입력된다는 것을 명시

struct PixelInput
{
	float4 position : SV_Position;
	float4 color : COLOR;
};


float4 PS(PixelInput input) : SV_TARGET
{
	
	if(
		input.color.x == 1.0f && 
		input.color.y == 1.0f && 
		input.color.z == 1.0f  
		) // 입력받은 꼭지점이 원래부터 색을 가지고 있지 않았다면
    {
        return color; // 색상버퍼만 적용
    }
	else // 입력받은 꼭지점이 뭔가 색을 가지고 있었다면
    {
        return input.color; // 그 꼭지점의 색상만 적용
    }
	
	// 저번까진 앞의 input.color만 이용해서 색을 출력했는데
	// 이제부턴 입력받은 색 버퍼의 값까지 고려해 색상을 출력한다는 코드
	
	// 정확히는 입력받은 색상버퍼를 정점이 가지고 있는 색상에 곱해서
	// 그 결과값으로 출력하는 색상을 결정
	// -> 만약 입력받은 정점 자체가 1.0,1.0,1.0의 흰색이 아니라
	// 뭔가 다른 색이었다면
	// color 색상버퍼에 흰색이 들어가있다 했더라도
	// 곱셈의 결과는 1이 아닌 값이 될 터이니 흰 색이 나올 수 없음
	
	// 추가적으로 이렇게 기존의 색과 버퍼의 색을 곱하는 식으로 만들 경우엔
	// 필연적으로 원래부터 흰색이 아니었던 이상
	// 점차 색이 어두워질 수 밖에 없음
	// 그래서 지금 이 식은 어디까지나 이 셰이더가 어떻게 동작하는지를 확인하기 위해
	// 이렇게 만든 것일 뿐이고,
	// 원하는 색으로 출력하도록 하려면 위 식을 뭔가 다른 식으로 만들 필요가 있음
	// ex)입력받은 정점이 가지고 있는 색을 무시하고 버퍼의 색만 체크한다던지,
	// 그 반대로 색상버퍼는 무시하고 꼭지점이 가진 색만 이용한다던지
	
}
